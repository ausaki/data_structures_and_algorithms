# 电梯调度游戏

链接: [http://play.elevatorsaga.com](http://play.elevatorsaga.com)


电梯状态包括: 
  
  - 运行方向: 上, 下, 停止(不是暂停在某个楼层让乘客上下电梯, 而是因为没有乘客使用电梯而停止运行).

  - 当前楼层. 一, 电梯运行时即将到达的楼层, 便于判断是否要在该楼层暂停让乘客上下电梯. 二, 电梯当前暂停的楼层.

  - 电梯的负荷, 可以用于判断电梯是否满载, 主要是调度多个电梯时会用到.

  - 内部乘客按下的楼层按钮.

  - 外面乘客按下的上下按钮.

调度算法: 

- 使用上下循环扫描法.
  

各个版本:

- sched00.js

  初级版本, 使用简单的上下扫描方法. 从第 1 层往顶层运行, 中途检测是否需要停下来让里面的乘客出去或者让外面的乘客进来. 当到了顶层后, 改变方向往第 1 层运行, 一直这样循环往复.

  通过前三关基本没问题, 偶尔会失败(差一点点). 

  优点是实现简单, 如果楼层比较少, 实际情况应该比复杂的调度算法表现更好. 缺点是楼层太多的话, 浪费时间在没有乘客的楼层.

  注意, 没有考虑多电梯的情况, 虽然也能调度多电梯, 但是效率非常差. 

- sched01.js

  相对于 sched00.js 稍微改进的版本. 当发现运行方向上没有乘客上下电梯时, 及时切换运行方向, 如果反方向仍然没有乘客, 那么直接停止运行.

  注意, 没有考虑多电梯的情况, 虽然也能调度多电梯, 但是效率非常差. 

- sched02.js

  多电梯版本.

关卡类型:

- 在指定时间内运输一定数量的乘客.

- 在指定的移动距离内运输完一定数量的乘客.

- 在指定的最大乘客等待时间内运输完一定数量的乘客.

我写的算法可以完成前两种类型的关卡, 第三种关卡往往会超时. 这也正好符合"上下循环扫描算法"的性质.

总结:

一开始花了不少时间去理解游戏中电梯的运行逻辑, 各个事件的触发逻辑. 

- "passing_floor" 事件不是严格在抵达楼层之前触发的, 我最开始是预期当这个事件触发时, `elevator.currentFloor()` 返回的当前楼层和事件参数的 `floorNum` 是相差 1 的. 实际上, 有的时候 `elevator.currentFloor()` 的返回值和 `floorNum` 是相等的.

- `up_button_pressed` 和 `down_button_pressed` 事件只会触发一次, 不过乘客当没有坐上电梯时会再按一次. 我使用两个全局数组来保存上下按钮的状态, 如果一个楼层的向上按钮被按下了, 那么 `upcmds[i] = 1`, 如果向下按钮被按下了, 那么 `downcmds[i] = 1`.

- `goingUpIndicator` 和 `goingDownIndicator` 分别对应电梯的上下指示器. 设置为 `true` 则对应的指示器会打开, `false` 则会关闭. 指示器会影响乘客的行为.

- `destinationDirection`, 我一开始对这个值产生了误会, 以为它一直等于 "up" 或 "down", 只有在电梯停止运行时才会等于 "stopped". 然而, 当电梯暂停在某个楼层时, 它的值等于 "stopped".
  
  因此, 如果想要获取电梯的运行方向, 使用 `destinationDirection` 是不准确的. 可以通过 `goingUpIndicator` 和 `goingDownIndicator` 来获取电梯的运行方向.


